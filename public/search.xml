<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[模拟赛 水晶的排列 题解]]></title>
    <url>%2F2019%2F09%2F28%2F9-21-T3%2F</url>
    <content type="text"><![CDATA[题目描述给定 n 个水晶，第 i 个水晶的高度为 H i 。现在要求将这些水晶排成一排，要求相邻两个水晶之间的高度差均大于 k，问有多少种排法。 输入格式第一行两个整数 n,k。接下来 n 行，每行一个整数，第 i 行的整数表示 H i 。 输出格式输出一行一个整数表示排法的种类数。 样例输入4 13421 样例输出2 思路考虑进行状态压缩动态规划，设 F s,i 表示由集合 s 内的点排成一列，最后一个是第 i 个水晶，合法的方案数。那么我们显然只需枚举倒数第二个水晶 j，并保证两个水晶之间的高度差大于k 就行了，余下的将转化为子问题。转移方程为: $F_{s,i}=\sum_{j \in s,j\not= i}F_{s-{i},j}[|H_i-H_j|&gt;k]$时间复杂度$O(n^22^n)$ 代码1234567891011121314151617181920212223242526#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll n,k,maxstate,dp[(1&lt;&lt;18)-1][20],h[20],ans;int main()&#123; //freopen("3.in","r",stdin); scanf("%lld%lld",&amp;n,&amp;k); for(register int i=1;i&lt;=n;i++) scanf("%lld",&amp;h[i]); maxstate=(1&lt;&lt;n)-1; for(register int i=1;i&lt;=n;i++) dp[1&lt;&lt;(i-1)][i]=1; for(register int s=1;s&lt;=maxstate;s++)&#123; for(register int i=1;i&lt;=n;i++)&#123; for(register int j=1;j&lt;=n;j++)&#123; if(i==j) continue; if(abs(h[i]-h[j])&gt;k&amp;&amp;(!((s&gt;&gt;(j-1))&amp;1))) dp[s|(1&lt;&lt;(j-1))][j]+=dp[s][i]; &#125; &#125; &#125; for(register int i=1;i&lt;=n;i++) ans+=dp[maxstate][i]; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9_22_T3 模拟赛 遗迹净化 题解]]></title>
    <url>%2F2019%2F09%2F26%2F9-22-T3%2F</url>
    <content type="text"><![CDATA[题目描述不知几千年后，本应死去的遗迹，如今却迎来了客人。 拔起了圣剑的你，为追溯过往，从这里开始了冒险的旅程。进入遗迹后，利用探知术，你得知了遗迹中包括入口处在内共有N个探索点，它们由M条双向通道相连通，通道的长度不尽相同。由于遗迹已在地下尘封多年，通道里都充满着污秽。你需要先净化掉所有的污秽，才能迈出探索的脚步。 从遗迹入口开始，将N个探索点从1到N编号。首先，你可以使用神圣驱魔术，净化以你为中心的一定区域内的所有道路。即，消耗数值为C×X的魔力点（C为常数），选定一个非负整数距离X。对于一条通道，若其两端的探索点与1号探索点间的距离均不大于X，则这条通道将被净化。这里，两探索点i与j间的距离定义为从i到j需经通道的长度之和的最小值。之后，你需要分别净化其余的所有通道，净化一条通道所需消耗魔力点即为这条通道的长度。 请确定净化的方式，使你需要消耗魔力点的数值最小。 输入格式第一行包含三个正整数 N、M、C，分别表示遗迹中探索点数量、通道数量和与使用神圣净化术时消耗魔力点数值有关的常数。 接下来M行，其中第i行包含3个整数Ai、Bi、Di，表示第i条通道连接着编号为Ai和Bi的两个探索点，长度为Di。 输出格式请输出1个整数，表示你需要消耗魔力点的最小值。 样例输入5 5 22 3 13 1 22 4 31 2 42 5 5 样例输出14 数据规模与约定对于32%的数据，N&lt;=100，M &lt;= 200，C &lt;= 100；Di &lt;= 10．对于64%的数据，N&lt;=100，M&lt;=4000对于100%的数据，2 &lt;= N &lt;= 100000，1 &lt;= M &lt;= 200000，1 &lt;= C &lt;= 100000；1 &lt;= Ai、Bi &lt;= N，Ai ≠ Bi，1 &lt;= Di &lt;= 100000两个探索点间直接连接的通道不超过一条。 思路简化题意：让你找一个距离，到一条边的距离（定义为两个点当中距离更大的那个点的最短距离）比该距离短的边可以用一个费用一次性全部净化，其他的边全部要手动净化 首先需要跑一遍最短路，处理出1号点到每个点的最短路，然后遍历所有的边，每条边两个点取最大值，然后按这个最大值给所有边排序，同时预处理出一个前缀和$sum_c$为需要净化的费用总和，然后在数组中寻找最小值断点更新答案即可. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const int maxn=100005,maxm=200005;ll ans,sumc,n,m,c,tot,head[maxn],ver[maxm&lt;&lt;1],edge[maxm&lt;&lt;1],Nxt[maxm&lt;&lt;1],dis[maxn];bool vis[maxn];priority_queue&lt; pair&lt;ll,ll&gt; &gt; q;struct node&#123; ll cost; ll dist;&#125;xl[maxm];struct ed&#123; ll u; ll v; ll l;&#125;E[maxm];inline void add(ll u,ll v,ll l)&#123; ver[++tot]=v,edge[tot]=l,Nxt[tot]=head[u],head[u]=tot;&#125;inline bool cmp(node cp1,node cp2)&#123; return cp1.dist&lt;cp2.dist;&#125;inline void dijkstra()&#123; for(register int i=1;i&lt;=n;i++) dis[i]=0x7ffffff; q.push(make_pair(0,1)); dis[1]=0; while(!q.empty())&#123; // printf("Yes\n"); int u=q.top().second;q.pop(); if(vis[u]) continue; vis[u]=true; // printf("%lld\n",u); for(register ll i=head[u];i;i=Nxt[i])&#123; // printf("%lld\n",ver[i]); if(dis[ver[i]]&gt;dis[u]+edge[i]) dis[ver[i]]=dis[u]+edge[i],q.push(make_pair(-dis[ver[i]],ver[i])); &#125; &#125;&#125;int main()&#123;// freopen("vestige.in","r",stdin);// freopen("vestige.out","w",stdout); scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;c); for(register int i=1;i&lt;=m;i++)&#123; ll u,v,l; scanf("%lld%lld%lld",&amp;u,&amp;v,&amp;l); // printf("%lld %lld %lld\n",u,v,l); E[i].u=u,E[i].v=v,E[i].l=l;sumc+=l; add(u,v,l);add(v,u,l); &#125; dijkstra();// for(register int i=1;i&lt;=n;i++) printf("%lld\n",dis[i]); for(register int i=1;i&lt;=m;i++) xl[i].cost=E[i].l,xl[i].dist=max(dis[E[i].u],dis[E[i].v]); sort(xl+1,xl+m+1,cmp); ans=sumc; for(register int i=1;i&lt;=m;i++)&#123; sumc-=xl[i].cost,ans=min(ans,1LL*c*xl[i].dist+sumc); printf("%lld %lld\n",xl[i].dist,ans); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>dijkstra</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9_22_T2 模拟赛 排干净月潭水塘 题解]]></title>
    <url>%2F2019%2F09%2F22%2F9-22-T2%2F</url>
    <content type="text"><![CDATA[问题描述净月潭公园里有n个水塘，因为要做OIER们的宿营地，需要把这n个水塘中的水排干，水塘中的水在自然条件下1个单位的时间可以蒸发A升水。现在买了1台抽水机，使用抽水机可以让你用1个单位的时间使每个水塘除开自然蒸发的A升水外，还可抽B升水，但在1个单位的时间内只能对1个水塘使用。 要你求出排干所有水塘的最少时间（水塘中的水为0时为排干）。 输入格式第一行N，A，B； 接下来N行，a1,a2,…aN每行一个数，表示每个水塘中水的升数。 输出格式一行一个整数，表示排干所有水塘的最少时间。 样例输入3 2 1123 样例输出1 数据规模与约定对于10%数据：N ≤ 5，1&lt;=ai,A,B&lt;=10对于40%数据：N ≤ 5000，1&lt;=ai,A,B&lt;=5000对于100%数据：N ≤ 500000，1&lt;=ai,A,B&lt;=500000 思路看数据范围应该能想到二分，二分一个总时间$mid$，然后只要一个水池超过该时间就全力去抽，最后判断时间是否合法。 代码12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxn=500005;int ans,mid,l,r,n,A,B;int sz[maxn];inline bool check(int x)&#123; int res=0;//×ÜÊ±¼ä for(register int i=1;i&lt;=n;i++) if(x*A&lt;sz[i]) res+=(sz[i]-x*A+B-1)/B; if(res&lt;=x) return true; return false;&#125;int main()&#123;// freopen("dry.in","r",stdin);// freopen("dry.out","w",stdout); scanf("%d%d%d",&amp;n,&amp;A,&amp;B); for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;sz[i]),r=max(r,sz[i]/A); l=1,r+=2; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(check(mid))&#123; r=mid-1; ans=mid; &#125;else l=mid+1; &#125; printf("%d",ans); return 0;&#125; qu]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.22模拟赛 二十四点 题解]]></title>
    <url>%2F2019%2F09%2F22%2F9-22-T1%2F</url>
    <content type="text"><![CDATA[问题描述给定n个数，不能改变顺序，可以再中间添加加号、减号或乘号，求有多少种算式可以算出24。 输入格式第一行一个正整数n。接下来n行每行一个整数，第i行表示第i个数。 输出格式一行一个整数，输出满足条件的算式个数。 样例输入5102424 样例输出5 数据规模对于10%的数据，n=2对于40%的数据，n&lt;=5对于100%的数据，n&lt;=10 思路很明显是一个深搜，不用剪枝就能过，但是要注意不能从pos=0开始乘和减。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int n,sz[15],fac[15],sum[15],ans;inline void dfs(int pos,int now)&#123;// printf("%d %d\n",pos,now);// if(now&gt;24&amp;&amp;sum[n]-sum[pos]&lt;now-24) return;// if(now&lt;24&amp;&amp;sum[n]-sum[pos]&lt;24-now) return;// printf("Yes\n"); if(pos==n)&#123; if(now==24)&#123; // printf("Yes\n"); ans++; &#125; return; &#125; int res=sz[pos+1]; for(register int i=pos+2;i&lt;=n;i++)&#123; res*=sz[i]; dfs(i,now+res); if(pos!=0)dfs(i,now-res); &#125; if(pos!=0) dfs(pos+1,now-sz[pos+1]); dfs(pos+1,now+sz[pos+1]);&#125;int main()&#123; freopen("z24a.in","r",stdin); freopen("z24a.out","w",stdout); scanf("%d",&amp;n); fac[0]=1; for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;sz[i]),sum[i]=sum[i-1]+sz[i]; dfs(0,0); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3268 奶牛农场 题解]]></title>
    <url>%2F2019%2F09%2F22%2Fpoj3268%2F</url>
    <content type="text"><![CDATA[题目链接传送门 Description 题目描述One cow from each of N farms (1 ≤ N ≤ 1000) conveniently numbered 1..N is going to attend the big cow party to be held at farm #X (1 ≤ X ≤ N). A total of M (1 ≤ M ≤ 100,000) unidirectional (one-way roads connects pairs of farms; road i requires Ti (1 ≤ Ti ≤ 100) units of time to traverse. Each cow must walk to the party and, when the party is over, return to her farm. Each cow is lazy and thus picks an optimal route with the shortest time. A cow’s return route might be different from her original route to the party since roads are one-way. Of all the cows, what is the longest amount of time a cow must spend walking to the party and back? 题意简述题意简述：有N个农场，编号为1到N，用M条单向道路连接，其中通过第i条道路所需的时间是Ti。 现在所有农场中的牛都要走到X号农场(1&lt;=X&lt;=N)开派对，并在派对后返回自己的农场。当然，去的路和回来的路可能不同，因为路是单向的。 每头牛都很懒，他们会选择消耗时间总和最短的路径来走。求所有牛在路上花费的时间的最大值。 Input 输入Line 1: Three space-separated integers, respectively: N, M, and XLines 2..M+1: Line i+1 describes road i with three space-separated integers: Ai, Bi, and Ti. The described road runs from farm Ai to farm Bi, requiring Ti time units to traverse. Output 输出Line 1: One integer: the maximum of time any one cow must walk. Sample Input 样例输入4 8 21 2 41 3 21 4 72 1 12 3 53 1 23 4 44 2 3 Sample Output 样例输出10 思路由于道路不是双向的，所以去和回的最短路是不同的。 回去的最短路明显是从排队地点处理一遍dis，那么来的路处理一次，然后变为反图再跑一次就好了。 然后遍历更新答案即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn=1005,maxm=10005;priority_queue&lt; pair&lt;int,int&gt; &gt; q;int ans,dis[maxn],n,m,x,head[maxn],ver[maxm&lt;&lt;1],edge[maxm&lt;&lt;1],Nxt[maxm&lt;&lt;1],tot;int dis_2[maxn],head_2[maxn],ver_2[maxm&lt;&lt;1],edge_2[maxm&lt;&lt;1],Nxt_2[maxm&lt;&lt;1],tot_2;bool vis[maxn],vis_2[maxn];inline void add(int u,int v,int l)&#123; ver[++tot]=v,Nxt[tot]=head[u],edge[tot]=l,head[u]=tot;&#125;inline void add_2(int u,int v,int l)&#123; ver_2[++tot_2]=v,Nxt_2[tot_2]=head_2[u],edge_2[tot_2]=l,head_2[u]=tot_2;&#125;inline void dijkstra()&#123; while(!q.empty()) q.pop(); for(register int i=1;i&lt;=n;i++) dis[i]=192608171; dis[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second;q.pop(); if(vis[u]) continue; vis[u]=true; for(register int i=head[u];i;i=Nxt[i])&#123; int v=ver[i]; if(dis[v]&gt;dis[u]+edge[i])&#123;dis[v]=dis[u]+edge[i];q.push(make_pair(-dis[v],v));&#125; &#125; &#125;&#125;inline void dijkstra_2()&#123; while(!q.empty()) q.pop(); for(register int i=1;i&lt;=n;i++) dis_2[i]=192608171; dis_2[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second;q.pop(); if(vis_2[u]) continue; vis_2[u]=true; for(register int i=head_2[u];i;i=Nxt_2[i])&#123; int v=ver_2[i]; if(dis_2[v]&gt;dis_2[u]+edge_2[i])&#123;dis_2[v]=dis_2[u]+edge_2[i];q.push(make_pair(-dis_2[v],v));&#125; &#125; &#125;&#125;int main()&#123; //freopen("party.in","r",stdin); //freopen("party.out","w",stdout); scanf("%d%d%d",&amp;n,&amp;m,&amp;x); for(register int i=1;i&lt;=m;i++)&#123; int u,v,l; scanf("%d%d%d",&amp;u,&amp;v,&amp;l); add(u,v,l);add_2(v,u,l); &#125; dijkstra(); dijkstra_2(); for(register int i=1;i&lt;=n;i++)&#123; ans=max(ans,dis[i]+dis_2[i]); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4821 [中山市选]生成树 题解]]></title>
    <url>%2F2019%2F09%2F22%2FP4821%2F</url>
    <content type="text"><![CDATA[题目链接传送门 题目描述有一种图形叫做五角形圈。一个五角形圈的中心有1个由n个顶点和n条边组成的圈。在中心的这个n边圈的每一条边同时也是某一个五角形的一条边，一共有n个不同的五角形。这些五角形只在五角形圈的中心的圈上有公共的顶点。如图0所示是一个4-五角形圈。 现在给定一个n五角形圈，你的任务就是求出n五角形圈的不同生成树的数目。还记得什么是图的生成树吗？一个图的生成树是保留原图的所有顶点以及顶点的数目减去一这么多条边,从而生成的一棵树。 由于这样的生成树数目可能过多，你只需要输出答案对2007的模数即可。 输入格式输入包含多组测试数据。第一行包含一个正整数T，表示测试数据数目。每组测试数据包含一个整数n( 2&lt;=N&lt;=100)，代表你需要求解的五角形圈中心的边数。 输出格式对每一组测试数据，输出一行包含一个整数x，表示n五角形圈的生成树数目模2007之后的结果。 样例输入12 样例输出40 思路很明显需要断$n-1$条边，然后打表看看$n=2$和$n=3$的情况，会发现需要断正多边形上的边然后其中一个五边形要再再删去一条边，且这条边必须要在中心圈上，于是根据乘法原理即为$4n5^{n-1}$。快速幂即可。 代码12345678910111213141516171819202122#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const ll mod=2007;ll n,ans,T;inline ll power(ll a,ll b)&#123; ll res=1LL; while(b)&#123;if(b&amp;1)(res*=a%mod)%=mod;(a*=a%mod)%=mod;b&gt;&gt;=(1LL);&#125; return res;&#125;int main()&#123; scanf("%lld",&amp;T); for(register int xh=1;xh&lt;=T;xh++)&#123; scanf("%lld",&amp;n); printf("%lld\n",4LL*n%mod*power(5,n-1)%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>结论题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codevs2370 小机房的树 题解]]></title>
    <url>%2F2019%2F09%2F20%2Fcodevs2370%2F</url>
    <content type="text"><![CDATA[题目链接传送门 题目描述 Description小机房有棵焕狗种的树，树上有N个节点，节点标号为0到N-1，有两只虫子名叫飘狗和大吉狗，分居在两个不同的节点上。有一天，他们想爬到一个节点上去搞基，但是作为两只虫子，他们不想花费太多精力。已知从某个节点爬到其父亲节点要花费 c 的能量（从父亲节点爬到此节点也相同），他们想找出一条花费精力最短的路，以使得搞基的时候精力旺盛，他们找到你要你设计一个程序来找到这条路，要求你告诉他们最少需要花费多少精力 输入描述 Input Description第一行一个n，接下来n-1行每一行有三个整数u，v, c 。表示节点 u 爬到节点 v 需要花费 c 的精力。第n+1行有一个整数m表示有m次询问。接下来m行每一行有两个整数 u ，v 表示两只虫子所在的节点 输出描述 Output Description一共有m行，每一行一个整数，表示对于该次询问所得出的最短距离。 样例输入 Sample Input3 1 0 1 2 0 1 3 1 0 2 0 1 2 样例输出 Sample Output1 1 2 数据范围及提示 Data Size &amp; Hint1&lt;=n&lt;=50000， 1&lt;=m&lt;=75000， 0&lt;=c&lt;=1000 思路LCA的一个性质:树上任意两点间的最短距离长度等于他们两个到树根的距离减去两倍LCA到树根的距离. 于是利用这个性质,求出LCA后直接回答即可. 代码123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxn=500005,maxm=500005;int n,m;int edge[maxn],dis[maxn],dep[maxn],tot,f[maxn][20],lg[maxn],head[maxn],ver[maxm&lt;&lt;1],Nxt[maxm&lt;&lt;1];inline void add(int u,int v,int l)&#123; ver[++tot]=v,edge[tot]=l,Nxt[tot]=head[u],head[u]=tot;&#125;inline void dfs(int u,int fa)&#123; f[u][0]=fa,dep[u]=dep[fa]+1; for(register int i=1;(1&lt;&lt;i)&lt;=dep[u];i++) f[u][i]=f[f[u][i-1]][i-1]; for(register int i=head[u];i;i=Nxt[i]) if(ver[i]!=fa) dis[ver[i]]=dis[u]+edge[i],dfs(ver[i],u);&#125;inline int lca(int u,int v)&#123; if(dep[u]&lt;dep[v]) swap(u,v); while(dep[u]&gt;dep[v]) u=f[u][lg[dep[u]-dep[v]]-1]; if(u==v) return u; for(register int i=lg[dep[u]]-1;i&gt;=0;i--) if(f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; return f[u][0];&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;n;i++)&#123;int u,v,l;scanf("%d%d%d",&amp;u,&amp;v,&amp;l);u+=1,v+=1,add(u,v,l),add(v,u,l);&#125; dfs(1,0); scanf("%d",&amp;m); for(register int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); for(register int i=1;i&lt;=m;i++)&#123;int u,v;scanf("%d%d",&amp;u,&amp;v);u+=1,v+=1;printf("%d\n",dis[u]+dis[v]-2*dis[lca(u,v)]);&#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod1674 区间的价值V2 题解]]></title>
    <url>%2F2019%2F09%2F19%2F51nod1674%2F</url>
    <content type="text"><![CDATA[题目链接传送门 题目描述lyk拥有一个区间。 它规定一个区间的价值为这个区间中所有数and起来的值与这个区间所有数or起来的值的乘积。 例如3个数2,3,6。它们and起来的值为2，or起来的值为7，这个区间对答案的贡献为2*7=14。 现在lyk有一个n个数的序列，它想知道所有n*(n+1)/2个区间的贡献的和对1000000007取模后的结果是多少。 例如当这个序列为{3,4,5}时，那么区间[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]的贡献分别为9,0,0,16,20,25。 输入第一行一个数n(1&lt;=n&lt;=100000)。接下来一行n个数ai，表示这n个数(0&lt;=ai&lt;=10^9)。 输出仅一行表示答案 样例输入33 4 5 样例输出70 思路由于与运算和或运算都具有收敛性：即参与运算的数越多结果则越靠拢0或1，那么我们就可以对离散化的答案开一个map，然后对一个区间进行分治，然后将相同的答案累计个数并乘起来即可，注意取模的位置。 代码12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;const int maxn=100005;ll sz[maxn],n,AND[maxn],OR[maxn],ans;map&lt;pair&lt;ll,ll&gt;,ll&gt; mp,mp2;map&lt;pair&lt;ll,ll&gt;,ll&gt;::iterator it,it2;//第一维为与，第二维为或inline void solve(int L,int R)&#123;// printf("%d %d\n",L,R); if(L&gt;R) return; int mid=(L+R)&gt;&gt;1; mp.clear(),mp2.clear(); AND[mid]=sz[mid],OR[mid]=sz[mid],mp[make_pair(sz[mid],sz[mid])]++,mp2[make_pair(sz[mid],sz[mid])]++; for(register int i=mid-1;i&gt;=L;i--) AND[i]=AND[i+1]&amp;sz[i],OR[i]=OR[i+1]|sz[i],mp[make_pair(AND[i],OR[i])]++; for(register int i=mid+1;i&lt;=R;i++) AND[i]=AND[i-1]&amp;sz[i],OR[i]=OR[i-1]|sz[i],mp2[make_pair(AND[i],OR[i])]++; for(it=mp.begin();it!=mp.end();it++) for(it2=mp2.begin();it2!=mp2.end();it2++) ans=(ans+((*it).first.first&amp;(*it2).first.first)*((*it).first.second|(*it2).first.second)%mod*(*it).second*(*it2).second)%mod; solve(L,mid-1);solve(mid+1,R);&#125;int main()&#123; scanf("%lld",&amp;n); for(register int i=1;i&lt;=n;i++) scanf("%lld",&amp;sz[i]); solve(1,n); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1125 Stockbroker Grapevine 题解]]></title>
    <url>%2F2019%2F09%2F19%2Fpoj1125%2F</url>
    <content type="text"><![CDATA[题目链接传送门 Description 题目描述Stockbrokers are known to overreact to rumours. You have been contracted to develop a method of spreading disinformation amongst the stockbrokers to give your employer the tactical edge in the stock market. For maximum effect, you have to spread the rumours in the fastest possible way. Unfortunately for you, stockbrokers only trust information coming from their “Trusted sources” This means you have to take into account the structure of their contacts when starting a rumour. It takes a certain amount of time for a specific stockbroker to pass the rumour on to each of his colleagues. Your task will be to write a program that tells you which stockbroker to choose as your starting point for the rumour, as well as the time it will take for the rumour to spread throughout the stockbroker community. This duration is measured as the time needed for the last person to receive the information. Input 输入Your program will input data for different sets of stockbrokers. Each set starts with a line with the number of stockbrokers. Following this is a line for each stockbroker which contains the number of people who they have contact with, who these people are, and the time taken for them to pass the message to each person. The format of each stockbroker line is as follows: The line starts with the number of contacts (n), followed by n pairs of integers, one pair for each contact. Each pair lists first a number referring to the contact (e.g. a ‘1’ means person number one in the set), followed by the time in minutes taken to pass a message to that person. There are no special punctuation symbols or spacing rules. Each person is numbered 1 through to the number of stockbrokers. The time taken to pass the message on will be between 1 and 10 minutes (inclusive), and the number of contacts will range between 0 and one less than the number of stockbrokers. The number of stockbrokers will range from 1 to 100. The input is terminated by a set of stockbrokers containing 0 (zero) people. Output 输出For each set of data, your program must output a single line containing the person who results in the fastest message transmission, and how long before the last person will receive any given message after you give it to this person, measured in integer minutes.It is possible that your program will receive a network of connections that excludes some persons, i.e. some people may be unreachable. If your program detects such a broken network, simply output the message “disjoint”. Note that the time taken to pass the message from person A to person B is not necessarily the same as the time taken to pass it from B to A, if such transmission is possible at all. Sample Input 样例输入32 2 4 3 52 1 2 3 62 1 2 2 253 4 4 2 8 5 31 5 84 1 6 4 10 2 7 5 202 2 5 1 50 Sample Output 样例输出3 23 10 思路题意简述:有n个人,他们要以最快速度互相传递一个消息,现在已知每个人可以传递的人及传递时间,求能用最短时间传递完信息的1那个人 n小于100,然后根据题意可知答案是一个能将消息传递给其他所有人且传递最长时间最短的人,于是跑一遍floyd然后$\mathcal O(n^2)$统计即可得出答案. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int n,f[105][105],ans,pos;inline void init()&#123; for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=n;j++) f[i][j]=192608171; for(register int i=1;i&lt;=n;i++) f[i][i]=0; ans=0x7ffffff;&#125;inline void floyd()&#123; for(register int k=1;k&lt;=n;k++)&#123; for(register int i=1;i&lt;=n;i++)&#123; for(register int j=1;j&lt;=n;j++)&#123; f[i][j]=min(f[i][j],f[i][k]+f[k][j]); &#125; &#125; &#125;&#125;inline void solve()&#123; for(register int i=1;i&lt;=n;i++)&#123; int tmp=0; bool vis=false; for(register int j=1;j&lt;=n;j++)&#123; if(f[i][j]==192608171) &#123;vis=true;break;&#125; else if(f[i][j]&gt;tmp) tmp=f[i][j]; &#125; if(vis) continue; if(tmp&lt;ans)&#123;ans=tmp,pos=i;&#125; &#125;&#125;int main()&#123; while(scanf("%d",&amp;n)&amp;&amp;n)&#123; init(); for(register int i=1;i&lt;=n;i++)&#123; int m;scanf("%d",&amp;m); for(register int j=1;j&lt;=m;j++)&#123; int tmp,l;scanf("%d%d",&amp;tmp,&amp;l),f[i][tmp]=min(f[i][tmp],l);&#125; floyd(); solve(); &#125; printf("%d %d\n",pos,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2481 Cows 题解]]></title>
    <url>%2F2019%2F09%2F18%2Fpoj2481%2F</url>
    <content type="text"><![CDATA[题目链接传送门 Description 问题描述 Farmer John’s cows have discovered that the clover growing along the ridge of the hill (which we can think of as a one-dimensional number line) in his field is particularly good. Farmer John has N cows (we number the cows from 1 to N). Each of Farmer John’s N cows has a range of clover that she particularly likes (these ranges might overlap). The ranges are defined by a closed interval [S,E]. But some cows are strong and some are weak. Given two cows: cowi and cowj, their favourite clover range is [Si, Ei] and [Sj, Ej]. If Si &lt;= Sj and Ej &lt;= Ei and Ei - Si &gt; Ej - Sj, we say that cowi is stronger than cowj. For each cow, how many cows are stronger than her? Farmer John needs your help! Input 输入The input contains multiple test cases.For each test case, the first line is an integer N (1 &lt;= N &lt;= 105), which is the number of cows. Then come N lines, the i-th of which contains two integers: S and E(0 &lt;= S &lt; E &lt;= 105) specifying the start end location respectively of a range preferred by some cow. Locations are given as distance from the start of the ridge. The end of the input contains a single 0. Output 输出For each test case, output one line containing n space-separated integers, the i-th of which specifying the number of cows that are stronger than $cow_i$. Sample Input 样例输入31 20 33 40 Sample Output 样例输出1 0 0 思路题意简述：一头奶牛能吃区间$[l,r]$的草，如果任意一头奶牛的这个范围在另一头奶牛的这个范围之内（重合除外），那么我们就说另一头奶牛更强壮，求出比每一头奶牛强壮的奶牛的数量。 我们可以根据每个奶牛的区间的左端点排序，因为对于任意一个比它强的奶牛，左端点必定是在他左边的。然后对着坐标轴开一个树状数组，统计右端点到最大坐标间的奶牛个数，记录原始下标即可得到答案。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1e5+14;int n,c[maxn],ans[maxn],lst;struct cow&#123; int l; int r; int xb;&#125;sz[maxn];inline bool cmp(cow cp1,cow cp2)&#123; if(cp1.l==cp2.l) return cp1.r&gt;cp2.r; return cp1.l&lt;cp2.l;&#125;inline void add(int x,int val)&#123; for(;x&lt;=1e5+1;x+=x&amp;-x) c[x]+=val;&#125;inline int ask(int x)&#123; int res=0; for(;x&gt;0;x-=x&amp;-x) res+=c[x]; return res;&#125;int main()&#123; while(scanf("%d",&amp;n)==1&amp;&amp;n)&#123; lst=0; memset(c,0,sizeof(c)); for(register int i=1;i&lt;=n;i++) sz[i].xb=i,scanf("%d%d",&amp;sz[i].l,&amp;sz[i].r),sz[i].l+=1,sz[i].r+=1;// for(register int i=1;i&lt;=n;i++) printf("%d %d\n",sz[i].l,sz[i].r); sort(sz+1,sz+n+1,cmp); for(register int i=1;i&lt;=n;i++)&#123; // printf("xb:%d\n",sz[i].xb); int tmp=ask(1e5+1)-ask(sz[i].r-1); add(sz[i].r,1); if(sz[i].r==sz[i-1].r&amp;&amp;sz[i].l==sz[i-1].l) &#123;ans[sz[i].xb]=lst;continue;&#125; ans[sz[i].xb]=tmp,lst=tmp; &#125; for(register int i=1;i&lt;=n;i++)&#123; printf("%d",ans[i]); if(i!=n) printf(" "); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3155 [CQOI2009]叶子的染色 题解]]></title>
    <url>%2F2019%2F09%2F15%2FP3155%2F</url>
    <content type="text"><![CDATA[题目链接传送门 题目描述给一棵m个结点的无根树，你可以选择一个度数大于1的结点作为根，然后给一些结点（根、内部结点和叶子均可）着以黑色或白色。你的着色方案应该保证根结点到每个叶子的简单路径上都至少包含一个有色结点（哪怕是这个叶子本身）。 对于每个叶结点u，定义c[u]为从根结点从U的简单路径上最后一个有色结点的颜色。给出每个c[u]的值，设计着色方案，使得着色结点的个数尽量少。 输入格式第一行包含两个正整数m, n，其中n是叶子的个数，m是结点总数。结点编号为1，2，…，m，其中编号1，2，… ，n是叶子。以下n行每行一个0或1的整数（0表示黑色，1表示白色），依次为c[1]，c[2]，…，c[n]。以下m-1行每行两个整数a，b（1&lt;=a &lt; b &lt;= m），表示结点a和b 有边相连。 输出格式仅一个数，即着色结点数的最小值。 样例输入5 30101 42 54 53 5 样例输出2 思路基本的树形dp，设$f_{u,i}$为以$u$ 根节点的子树所需染色的最小节点数 发现对于一个节点只有白色，黑色，无色三种情况 于是就可以得到三个转移方程： $f_{u,0}=min(f_{u,2},f_{u,0}-1,f_{u,1})$ $f_{u,1}=min(f_{u,2},f_{u,0},f_{u,1}-1)$ $f_{u,2}=min(f_{u,2},f_{u,0},f_{u,1})$ ($v \in son[s]$) 然后dfs即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int n,m;const int maxm=10005*2,inf=1000000000;int deg[maxm],root,c[maxm],head[maxm],ver[maxm],Nxt[maxm],tot;int f[maxm][4];inline void add(int u,int v)&#123; ver[++tot]=v,Nxt[tot]=head[u],head[u]=tot;&#125;inline void dfs(int u,int fa)&#123; //printf("dfs:%d %d\n",u,fa); for(register int i=head[u];i;i=Nxt[i])&#123; if(ver[i]==fa) continue; dfs(ver[i],u); int v=ver[i]; f[u][0]+=min(f[v][2],min(f[v][1],f[v][0]-1)); f[u][1]+=min(f[v][2],min(f[v][1]-1,f[v][0])); f[u][2]+=min(f[v][2],min(f[v][1],f[v][0])); &#125;&#125;inline void init()&#123; for(register int i=1;i&lt;=m;i++)&#123; if(i&lt;=n) f[i][c[i]]=1,f[i][!c[i]]=inf,f[i][2]=1; else f[i][0]=1,f[i][1]=1; &#125;&#125;int main()&#123;// freopen("leaf.in","r",stdin);// freopen("leaf.out","w",stdout); scanf("%d%d",&amp;m,&amp;n); for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;c[i]); for(register int i=1;i&lt;m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); //printf("%d %d\n",u,v); add(u,v);add(v,u); deg[u]++,deg[v]++; if(deg[u]&gt;1&amp;&amp;!root) &#123; root=u; // printf("uYes"); &#125; if(deg[v]&gt;1&amp;&amp;!root)&#123; root=v; // printf("vYes%d\n",deg[4]); &#125; &#125; init(); dfs(root,0); printf("%d",min(f[root][2],min(f[root][1],f[root][0]))); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1627 [CQOI2009]中位数 题解]]></title>
    <url>%2F2019%2F09%2F15%2FP1627%2F</url>
    <content type="text"><![CDATA[题目描述给出1~n的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。中位数是指把所有元素从小到大排列后，位于中间的数。 输入格式第一行为两个正整数n和b，第二行为1~n的排列。 【数据规模】对于30%的数据中，满足n≤100；对于60%的数据中，满足n≤1000；对于100%的数据中，满足n≤100000,1≤b≤n。 输出格式输出一个整数，即中位数为b的连续子序列个数。 样例输入7 45 7 2 4 3 1 6 样例输出4 思路由于此题给出的数列是一个全排列，考虑把大于b的数转换为1，小于b的数转换为0，那么满足题意的数就是包含b的一段和为0的连续子序列，所以我们可以在一开始就找到中位数b所在的位置，然后向前向后扫，设$cntl_i$和$cntr_i$分别表示左边与右边前缀和为$i$的子序列的个数，那么答案就是$\sum_{i=-n+1}^n cntl_i*cntr_{0-i}$ 因为下表不能表示负数，所以把前缀和全部加上n即可。 代码12345678910111213141516171819202122232425262728#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxn=100005;int n,m,sz[maxn],idx,suml[maxn*2],sumr[maxn*2];long long ans;int main()&#123;// freopen("median.in","r",stdin);// freopen("median.out","w",stdout); scanf("%d%d",&amp;n,&amp;m); for(register int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;sz[i]); if(sz[i]==m) idx=i; else if(sz[i]&gt;m) sz[i]=1; else sz[i]=-1; &#125; int sum=0; suml[n]=sumr[n]=1; for(register int i=idx-1;i&gt;=1;i--) sum+=sz[i],suml[sum+n]++; sum=0; for(register int i=idx+1;i&lt;=n;i++) sum+=sz[i],sumr[sum+n]++; for(register int i=-n+1;i&lt;=n-1;i++) ans+=suml[i+n]*sumr[0-i+n]; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4157 [SCOI2006]整数划分 题解]]></title>
    <url>%2F2019%2F09%2F15%2FP4157%2F</url>
    <content type="text"><![CDATA[题目描述从文件中读入一个正整数n（10≤n≤31000）。要求将n写成若干个正整数之和，并且使这些正整数的乘积最大。 例如，n=13，则当n表示为4+3+3+3（或2+2+3+3+3）时，乘积=108为最大。 输入格式只有一个正整数：n （10≤n≤31000） 输出格式第1行输出一个整数，为最大乘积的位数。 第2行输出最大乘积的前100位，如果不足100位，则按实际位数输出最大乘积。 （提示：在给定的范围内，最大乘积的位数不超过5000位）。 样例输入13 样例输出3108 思路可以证明，任意数分解成2和3都比其他数更优.假设说我们把一个数分解为比2和3更大的数，那么很明显的他能得到的乘积会更小。于是就优先分3,然后不断减小，直到不大于5.然后在5范围以内，可以知道4拆分成2+2更优加特判即可。 代码1234567891011121314151617181920212223242526272829303132#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int ans[1000005],tot,n;inline void Nxt()&#123; for(register int i=1;i&lt;=tot;i++) ans[i+1]+=(ans[i]/10),ans[i]%=10; while(ans[tot+1]!=0) tot++;&#125;inline void multi(int x)&#123; for(register int i=tot;i&gt;=1;i--)&#123; ans[i]*=x; &#125; Nxt();&#125;int main()&#123;// freopen("integer.in","r",stdin);// freopen("integer.out","w",stdout); ans[1]=1,tot=1; scanf("%d",&amp;n); while(n&gt;5)&#123;n-=3;multi(3);&#125; if(n==5) multi(6); else if(n==4) multi(4); else multi(n); Nxt(); printf("%d\n",tot); if(tot&lt;=100) for(register int i=tot;i&gt;=1;i--) printf("%d",ans[i]); else for(register int i=tot;i&gt;=tot-100+1;i--) printf("%d",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hzu2105 Digits Count 题解]]></title>
    <url>%2F2019%2F09%2F11%2Fhzu2105%2F</url>
    <content type="text"><![CDATA[Problem Description 问题描述Given N integers A={A[0],A[1],…,A[N-1]}. Here we have some operations: Operation 1: AND opn L R Here opn, L and R are integers. For L≤i≤R, we do A[i]=A[i] AND opn (here “AND” is bitwise operation). Operation 2: OR opn L R Here opn, L and R are integers. For L≤i≤R, we do A[i]=A[i] OR opn (here “OR” is bitwise operation). Operation 3: XOR opn L R Here opn, L and R are integers. For L≤i≤R, we do A[i]=A[i] XOR opn (here “XOR” is bitwise operation). Operation 4: SUM L R We want to know the result of A[L]+A[L+1]+…+A[R]. Now can you solve this easy problem? Input 输入The first line of the input contains an integer T, indicating the number of test cases. (T≤100) Then T cases, for any case, the first line has two integers n and m (1≤n≤1,000,000, 1≤m≤100,000), indicating the number of elements in A and the number of operations. Then one line follows n integers A[0], A[1], …, A[n-1] (0≤A[i]&lt;16,0≤i&lt;n). Then m lines, each line must be one of the 4 operations above. (0≤opn≤15) Output 输出For each test case and for each “SUM” operation, please output the result with a single line. Sample Input 样例输入14 41 2 4 7SUM 0 2XOR 5 0 0OR 6 0 3SUM 0 2 Sample Output 样例输出718 思路位运算的线段树。我们发现，由于opt&lt;16，所以可以开四棵线段树来记录每一位上的情况，同时标记也只有两种：区间置换和区间取反，注意的是两种标记下推时要相互处理消除影响。 最后求和分开统计即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1e6+10;int T,n,m,sz[maxn],val[5][maxn*4],lazy[5][maxn*4],XOR[5][maxn*4];//Segementreeinline void pushup(int id,int now)&#123; val[id][now]=val[id][now&lt;&lt;1]+val[id][now&lt;&lt;1|1];&#125;inline void pushdown(int id,int now,int l,int r)&#123; int mid=(l+r)&gt;&gt;1; if(lazy[id][now]!=-1)&#123; lazy[id][now&lt;&lt;1]=lazy[id][now],lazy[id][now&lt;&lt;1|1]=lazy[id][now]; val[id][now&lt;&lt;1]=lazy[id][now]?(mid-l+1):0,val[id][now&lt;&lt;1|1]=lazy[id][now]?(r-mid):0; lazy[id][now]=-1,XOR[id][now]=0; &#125;else if(XOR[id][now])&#123; val[id][now&lt;&lt;1]=(mid-l+1)-val[id][now&lt;&lt;1],val[id][now&lt;&lt;1|1]=(r-mid)-val[id][now&lt;&lt;1|1]; XOR[id][now&lt;&lt;1]^=XOR[id][now],XOR[id][now&lt;&lt;1|1]^=XOR[id][now],XOR[id][now]=0; if(lazy[id][now&lt;&lt;1]!=-1) lazy[id][now&lt;&lt;1]^=1,XOR[id][now&lt;&lt;1]=0; if(lazy[id][now&lt;&lt;1|1]!=-1) lazy[id][now&lt;&lt;1|1]^=1,XOR[id][now&lt;&lt;1|1]=0; &#125;&#125;inline void build(int l,int r,int now)&#123; //printf("%d %d %d\n",l,r,now); for(register int i=1;i&lt;=4;i++) &#123; // printf("%d %d\n",i,now); lazy[i][now]=-1,XOR[i][now]=0; &#125; if(l==r)&#123; for(register int id=1;id&lt;=4;id++)&#123;// printf("%d\n",val[id][now]); if((sz[l]&amp;(1&lt;&lt;(id-1)))) val[id][now]=1;else val[id][now]=0; // printf("%d %d %d %d\n",l,val[id][now],id,now); &#125; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,now&lt;&lt;1); build(mid+1,r,now&lt;&lt;1|1); for(register int id=1;id&lt;=4;id++) pushup(id,now);&#125;inline void change(int id,int L,int R,int l,int r,int now,int opt)&#123; if(l&lt;=L&amp;&amp;R&lt;=r)&#123; if(opt==1)&#123; val[id][now]=((R-L+1)-val[id][now]); XOR[id][now]=XOR[id][now]^1; if(lazy[id][now]!=-1) lazy[id][now]^=1,XOR[id][now]=0; &#125;else if(opt==2)&#123; val[id][now]=0; lazy[id][now]=0; XOR[id][now]=0; &#125;else if(opt==3)&#123; val[id][now]=(R-L+1); lazy[id][now]=1; XOR[id][now]=0; &#125; return; &#125; int mid=(L+R)&gt;&gt;1; pushdown(id,now,L,R); if(l&lt;=mid) change(id,L,mid,l,r,now&lt;&lt;1,opt); if(r&gt;mid) change(id,mid+1,R,l,r,now&lt;&lt;1|1,opt); pushup(id,now);&#125;inline int query(int id,int l,int r,int L,int R,int now)&#123;// printf("%d %d\n",l,r); int res=0; if(l&lt;=L&amp;&amp;R&lt;=r) return val[id][now]; pushdown(id,now,L,R); int mid=(L+R)&gt;&gt;1; if(l&lt;=mid) res+=query(id,l,r,L,mid,now&lt;&lt;1); if(r&gt;mid) res+=query(id,l,r,mid+1,R,now&lt;&lt;1|1); // pushup(id,now); return res;&#125;int main()&#123; //freopen("test.txt","r",stdin);// freopen("2.txt","w",stdout); scanf("%d",&amp;T);// printf("at:%d\n",val[4][4]); for(register int xh=1;xh&lt;=T;xh++)&#123;// printf("at:%d\n",val[4][4]) scanf("%d%d",&amp;n,&amp;m); for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;sz[i]); build(1,n,1); for(register int i=1;i&lt;=m;i++)&#123; // printf("Yes\n"); char ch; int qry,l,r; while((ch=getchar())&amp;&amp;(ch&lt;'A'||ch&gt;'Z')); if(ch=='S')&#123; while((ch=getchar())&amp;&amp;ch&gt;='A'&amp;&amp;ch&lt;='Z'); scanf("%d%d",&amp;l,&amp;r); l+=1,r+=1; int ans=0; for(register int id=1;id&lt;=4;id++)&#123; // printf("id:%d %d\n",id,query(id,l,r,1,n,1)); ans+=((1&lt;&lt;(id-1))*query(id,l,r,1,n,1)); &#125; printf("%d\n",ans); &#125;else if(ch=='O')&#123;//OR while((ch=getchar())&amp;&amp;ch&gt;='A'&amp;&amp;ch&lt;='Z'); scanf("%d%d%d",&amp;qry,&amp;l,&amp;r); l+=1,r+=1; for(register int id=1;id&lt;=4;id++)&#123; if(qry&amp;(1&lt;&lt;(id-1)))&#123; change(id,1,n,l,r,1,3); &#125; &#125; &#125;else if(ch=='X')&#123;//XOR while((ch=getchar())&amp;&amp;ch&gt;='A'&amp;&amp;ch&lt;='Z'); scanf("%d%d%d",&amp;qry,&amp;l,&amp;r); l+=1,r+=1; for(register int id=1;id&lt;=4;id++)&#123; if(qry&amp;(1&lt;&lt;(id-1)))&#123; change(id,1,n,l,r,1,1); &#125; &#125; &#125;else if(ch=='A')&#123;//AND while((ch=getchar())&amp;&amp;ch&gt;='A'&amp;&amp;ch&lt;='Z'); scanf("%d%d%d",&amp;qry,&amp;l,&amp;r); l+=1,r+=1; for(register int id=1;id&lt;=4;id++)&#123; if(!(qry&amp;(1&lt;&lt;(id-1))))&#123; change(id,1,n,l,r,1,2); &#125; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF292D Connected Components 题解]]></title>
    <url>%2F2019%2F09%2F10%2FCF292D%2F</url>
    <content type="text"><![CDATA[Problem Description 问题描述We already know of the large corporation where Polycarpus works as a system administrator. The computer network there consists of n computers and m cables that connect some pairs of computers. In other words, the computer network can be represented as some non-directed graph with n nodes and m edges. Let’s index the computers with integers from 1 to n, let’s index the cables with integers from 1 to m. Polycarpus was given an important task — check the reliability of his company’s network. For that Polycarpus decided to carry out a series of k experiments on the computer network, where the i-th experiment goes as follows: Temporarily disconnect the cables with indexes from $l_i$ to $r_i$, inclusive (the other cables remain connected). Count the number of connected components in the graph that is defining the computer network at that moment. Re-connect the disconnected cables with indexes from $l_i$ to $r_i$ (that is, restore the initial network). Help Polycarpus carry out all experiments and for each print the number of connected components in the graph that defines the computer network through the given experiment. Isolated vertex should be counted as single component. Input 输入The first line contains two space-separated integers $n, m (2 ≤ n ≤ 500; 1 ≤ m ≤ 10^4)$ — the number of computers and the number of cables, correspondingly. The following m lines contain the cables’ description. The i-th line contains space-separated pair of integers $x_i, y_i (1 ≤ x_i, y_i ≤ n; xi ≠ y_i)$ — the numbers of the computers that are connected by the i-th cable. Note that a pair of computers can be connected by multiple cables. The next line contains integer $k (1 ≤ k ≤ 2·10^4)$ — the number of experiments. Next k lines contain the experiments’ descriptions. The i-th line contains space-separated integers $l_i, r_i (1 ≤ l_i ≤ r_i ≤ m)$ — the numbers of the cables that Polycarpus disconnects during the i-th experiment. Output 输出Print $k$ numbers, the i-th number represents the number of connected components of the graph that defines the computer network during the i-th experiment. Sample Input 样例输入6 51 25 42 33 13 661 32 51 55 52 43 3 Sample Output 样例输出456342 思路由于本题的$n$很小,所以我们可以开一个前缀并查集$pre$和一个后缀并查集$suf$,对于每次查询,我们只要对前缀的$1,l-1$部分和后缀的$r+1,m$部分手动合并即可. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxm=10005;int x[10005],y[10005],n,m,k,pre[10005][505],suf[10005][505],fa[505];//UnionFindinline int get1(int sz,int x)&#123;return (x==pre[sz][x])?x:pre[sz][x]=get1(sz,pre[sz][x]);&#125;inline int get2(int sz,int x)&#123;return (x==suf[sz][x])?x:suf[sz][x]=get2(sz,suf[sz][x]);&#125;inline int get3(int x)&#123;return (x==fa[x])?x:fa[x]=get3(fa[x]);&#125;inline void merge1(int sz,int x,int y)&#123;if(x!=y)pre[sz][x]=y;&#125;inline void merge2(int sz,int x,int y)&#123;if(x!=y)suf[sz][x]=y;&#125;inline void merge3(int x,int y)&#123;if(x!=y)fa[x]=y;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(register int i=1;i&lt;=n;i++)&#123; pre[0][i]=i,suf[m+1][i]=i; &#125; for(register int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;x[i],&amp;y[i]); for(register int j=1;j&lt;=n;j++) pre[i][j]=pre[i-1][j]; merge1(i,get1(i,x[i]),get1(i,y[i])); &#125; for(register int i=m;i&gt;=1;i--)&#123; for(register int j=1;j&lt;=n;j++) suf[i][j]=suf[i+1][j]; merge2(i,get2(i,x[i]),get2(i,y[i])); &#125; /*for(register int i=1;i&lt;=m;i++)&#123; for(register int j=1;j&lt;=n;j++) printf("%d ",pre[i][j]); printf("\n"); &#125; for(register int i=m;i&gt;=1;i--)&#123; for(register int j=1;j&lt;=n;j++) printf("%d ",suf[i][j]); printf("\n"); &#125;*/ scanf("%d",&amp;k); for(register int i=1;i&lt;=k;i++)&#123; int ans=0; int l,r; scanf("%d%d",&amp;l,&amp;r); for(register int i=1;i&lt;=n;i++) fa[i]=pre[l-1][i]; for(register int i=1;i&lt;=n;i++) merge3(get3(i),get3(get2(r+1,i))); for(register int i=1;i&lt;=n;i++) if(get3(fa[i])==i) ans++; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2279[HNOI2003]消防局的设立 题解]]></title>
    <url>%2F2019%2F09%2F04%2FP2279%2F</url>
    <content type="text"><![CDATA[题目描述2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，我们称基地A到基地B的距离为d。 由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。 你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。 输入格式输入文件名为input.txt。 输入文件的第一行为n （n&lt;=1000），表示火星上基地的数目。接下来的n-1行每行有一个正整数，其中文件第i行的正整数为a[i]，表示从编号为i的基地到编号为a[i]的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有a[i]&lt;i。 输出格式输出文件名为output.txt 输出文件仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。 样例输入61235 样例输出2 思路标算是树形dp然而可以用贪心搞……嫌时间不够就暂时用贪心苟着。 考虑任意一个节点$node_i$，假如它能被处理，那么一定是他的爷爷，他的父亲节点，他的兄弟节点，他的儿子节点，他的孙子节点当中的任意一个部署有消防站。而很显然部署一个在他的爷爷的位置可以解决他和他兄弟，于是贪心的做法就是每次找出未被处理的深度最深的点，然后标记它的爷爷即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn=1005;int ans,fa[maxn],dep[maxn],n,head[maxn],ver[maxn&lt;&lt;1],Nxt[maxn&lt;&lt;1],tot;bool vis[maxn];priority_queue&lt; pair&lt;int,int&gt; &gt; pq;inline void add(int u,int v)&#123; ver[++tot]=v,Nxt[tot]=head[u],head[u]=tot;&#125;inline void dfs(int u,int f)&#123;// printf("%d %d\n",u,f); dep[u]=dep[f]+1; for(register int i=head[u];i;i=Nxt[i])&#123; if(ver[i]==f) continue; fa[ver[i]]=u; dfs(ver[i],u); &#125; pq.push(make_pair(dep[u],u));&#125;inline void deal(int u)&#123; vis[u]=true; for(register int i=head[u];i;i=Nxt[i])&#123; int tmp=ver[i]; // if(tmp==fa[u]) continue; vis[tmp]=true; for(register int j=head[tmp];j;j=Nxt[j]) vis[ver[j]]=true; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;n;i++)&#123; int tmp;scanf("%d",&amp;tmp); add(i+1,tmp),add(tmp,i+1); &#125; dfs(1,0); while(!pq.empty())&#123; while(!pq.empty()&amp;&amp;vis[pq.top().second]) pq.pop(); if(pq.empty()) break; int u=pq.top().second;pq.pop(); ans++; int ls; if(fa[fa[u]]) ls=fa[fa[u]];else ls=1; deal(ls); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1119 灾后重建 题解]]></title>
    <url>%2F2019%2F09%2F03%2FP1119%2F</url>
    <content type="text"><![CDATA[题目背景B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。 题目描述给出B地区的村庄数N，村庄编号从0到$N-1$，和所有M条公路的长度，公路是双向的。并给出第$i$个村庄重建完成的时间$t_i$，你可以认为是同时开始重建并在第$t_i$天重建完成，并且在当天即可通车。若$t_i$为0则说明地震未对此地区造成损坏，一开始就可以通车。之后有Q个询问(x,y,t)，对于每个询问你要回答在第t天，从村庄x到村庄y的最短路径长度为多少。如果无法找到从x村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未重建完成 ，则需要返回$-1$。 输入格式第一行包含两个正整数N,M，表示了村庄的数目与公路的数量。 第二行包含N个非负整数$t_i$，表示了每个村庄重建完成的时间，数据保证了t单调递增。 接下来M行，每行3个非负整数i,j,w，w为不超过10000的正整数，表示了有一条连接村庄ii与村庄jj的道路，长度为w，保证i≠j，且对于任意一对村庄只会存在一条道路。 接下来一行也就是M+3行包含一个正整数Q，表示Q个询问。 接下来Q行，每行3个非负整数x,y,t，询问在第$t$天，从村庄x到村庄y的最短路径长度为多少，数据保证了t是不下降的。 输出格式共Q行，对每一个询问(x,y,t)输出对应的答案，即在第t天，从村庄x到村庄y的最短路径长度为多少。如果在第t天无法找到从x村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未修复完成，则输出−1。 样例输入4 51 2 3 40 2 12 3 13 1 22 1 40 3 542 0 20 1 20 1 30 1 4 样例输出-1-154 思路由于时间具有单调不下降的性质，因此我们可以不断更新最短路 但是每次用dijkstra和spfa肯定会超时，考虑floyd,我们每次重建完成的村庄的序号是不下降的，回顾floyd的dp阶段，是以$k$个点作为阶段。 于是每当一个村庄重建完成后就把该阶段的答案更新即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int Q,n,m,f[205][205],Ti[205],bj;bool vis[205];inline void floyd(int k)&#123;// printf("k:%d\n",k); for(register int i=1;i&lt;=n;i++)&#123; for(register int j=1;j&lt;=n;j++)&#123; if(f[i][j]&gt;f[i][k]+f[k][j]) f[j][i]=f[i][j]=f[i][k]+f[k][j]; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); memset(vis,false,sizeof(vis)); for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;Ti[i]); for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=n;j++) f[j][i]=f[i][j]=99999999; for(register int i=1;i&lt;=n;i++) f[i][i]=0; for(register int i=1;i&lt;=m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); u+=1,v+=1; f[u][v]=f[v][u]=w; &#125; scanf("%d",&amp;Q); bj=1; for(register int i=1;i&lt;=Q;i++)&#123; int u,v,t; scanf("%d%d%d",&amp;u,&amp;v,&amp;t); u+=1,v+=1; while(Ti[bj]&lt;=t&amp;&amp;bj&lt;=n) vis[bj]=true,floyd(bj),bj++; if(vis[u]==false||vis[v]==false)&#123; printf("-1\n");continue; &#125; if(f[u][v]==99999999)&#123; printf("-1\n");continue; &#125; printf("%d\n",f[u][v]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1776 宝物筛选 题解]]></title>
    <url>%2F2019%2F09%2F03%2FP1776%2F</url>
    <content type="text"><![CDATA[题目描述终于，破解了千年的难题。小FF找到了王室的宝物室，里面堆满了无数价值连城的宝物……这下小FF可发财了，嘎嘎。但是这里的宝物实在是太多了，小FF的采集车似乎装不下那么多宝物。看来小FF只能含泪舍弃其中的一部分宝物了……小FF对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小FF有一个最大载重为W的采集车，洞穴里总共有n种宝物，每种宝物的价值为v[i]，重量为w[i]，每种宝物有m[i]件。小FF希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。 输入格式第一行为一个整数N和w，分别表示宝物种数和采集车的最大载重。 接下来n行每行三个整数，其中第i行第一个数表示第i类品价值，第二个整数表示一件该类物品的重量，第三个整数为该类物品数量。 输出格式输出仅一个整数ans，表示在采集车不超载的情况下收集的宝物的最大价值。 样例输入4 203 9 35 9 19 4 28 1 3 样例输出47 思路很裸的二进制拆分多重背包，拆分成能表示所有物品组合的物品即可。 代码1234567891011121314151617181920212223242526#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1000005;int n,maxv,ans,sz,v[maxn],val[maxn],dp[maxn],tot;int main()&#123; scanf("%d%d",&amp;n,&amp;maxv); for(register int i=1;i&lt;=n;i++)&#123; int w,b,c; scanf("%d%d%d",&amp;w,&amp;b,&amp;c); for(register int j=1;j&lt;=c;j&lt;&lt;=1) val[++tot]=w*j,v[tot]=b*j,c-=j; if(c) val[++tot]=w*c,v[tot]=b*c; &#125; dp[0]=0; for(register int i=1;i&lt;=tot;i++)&#123; for(register int j=maxv;j&gt;=v[i];j--)&#123; dp[j]=max(dp[j],dp[j-v[i]]+val[i]); &#125; &#125; for(register int i=1;i&lt;=maxv;i++) ans=max(ans,dp[i]); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>多重背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5172GTY's Gayfriends 题解]]></title>
    <url>%2F2019%2F09%2F02%2Fhdu5172%2F</url>
    <content type="text"><![CDATA[Problem Description 问题描述GTY has $n$ gay friends. To manage them conveniently, every morning he ordered all his gay friends to stand in a line. Every gay friend has a characteristic value $a_i$ , to express how manly or how girlish he is. You, as GTY’s assistant, have to answer GTY’s queries. In each of GTY’s queries, GTY will give you a range$ [l,r]$ . Because of GTY’s strange hobbies, he wants there is a permutation $[1..r−l+1]$ in $[l,r]$. You need to let him know if there is such a permutation or not. Input 输入Multi test cases (about 3) . The first line contains two integers n and m ($ 1≤n,m≤1000000$ ), indicating the number of GTY’s gay friends and the number of GTY’s queries. the second line contains n numbers seperated by spaces. The $i^{th}$ number ai ( 1≤$a_i$≤n ) indicates GTY’s ith gay friend’s characteristic value. The next m lines describe GTY’s queries. In each line there are two numbers l and r seperated by spaces ( $1≤l≤r≤n$ ), indicating the query range. Output 输出For each query, if there is a permutation$ [1..r−l+1]$ in $[l,r]$, print ‘YES’, else print ‘NO’. Sample Input 样例输入8 52 1 3 4 5 2 3 11 31 12 24 81 53 21 1 11 11 2 Sample Output 样例输出YESNOYESYESYESYESNO 思路这道题要求给出的区间是否是$[1,r-l+1]$的一个全排列，那么首先我们求一下是否对应和与原排列对应和相同。 然后的话就是看是否有重复的数出现，我们对于原数组每一个数$a_i$都记录一下其相同的值上次出现的位置，然后对这个位置开一颗维护$max$的线段树，然后查询区间内出现过的值是否上次出现位置都在$l$之前即可. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxn=2000015;int n,m,sz[maxn],lxt[maxn],pos[maxn];int val[maxn&lt;&lt;2];long long sum[maxn];inline void pushup(int p)&#123; val[p]=max(val[p&lt;&lt;1],val[p&lt;&lt;1|1]);&#125;inline void build(int l,int r,int p)&#123; if(l==r)&#123; val[p]=pos[l];return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,p&lt;&lt;1); build(mid+1,r,p&lt;&lt;1|1); pushup(p);&#125;inline int ask(int L,int R,int l,int r,int now)&#123; if(L&lt;=l&amp;&amp;R&gt;=r) return val[now] ; int res=0,mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,ask(L,R,l,mid,now&lt;&lt;1)); if(R&gt;mid) res=max(res,ask(L,R,mid+1,r,now&lt;&lt;1|1)); return res;&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)==2)&#123; memset(lxt,0,sizeof(lxt)); memset(val,0,sizeof(val)); for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;sz[i]),sum[i]=sum[i-1]+sz[i],pos[i]=lxt[sz[i]],lxt[sz[i]]=i; build(1,n,1); for(register int i=1;i&lt;=m;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); if((sum[r]-sum[l-1])!=(1LL*(r-l+2)*(r-l+1))/2)&#123; printf("NO\n"); continue; &#125; if(ask(l,r,1,n,1)&lt;l)&#123; printf("YES\n"); &#125;else printf("NO\n"); &#125; &#125; return 0; &#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客暑期noip提高组模拟(五) 解题报告]]></title>
    <url>%2F2019%2F08%2F24%2Fnowcoder5%2F</url>
    <content type="text"><![CDATA[A deco的abs思路设$delta_i==sz_i-sz_{i-1}$,那么对于任意的$delta_i$很明显我们可以对其加上任意大小的$d$使其绝对值最小,并且由于其他所有数操作次数都是无限的,所以可以任意修改不影响相对大小关系，然后不断取最小值即可。 代码12345678910111213141516171819202122232425#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int n,d,sz[10000005],delta[10000005];long long ans;int main()&#123; scanf("%d%d",&amp;n,&amp;d); for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;sz[i]),delta[i]=sz[i]-sz[i-1]; for(register int i=2;i&lt;=n;i++)&#123; if(delta[i]&lt;0)&#123; int pre=delta[i]%d; delta[i]%=d,delta[i]+=d; ans+=min(abs(pre),delta[i]); &#125;else if(delta[i]&gt;0)&#123; int pre=delta[i]%d; delta[i]%=d,delta[i]-=d; ans+=min(abs(delta[i]),pre); &#125;else if(delta[i]==0) continue; &#125; printf("%lld",ans); return 0;&#125; deco的gcd思路考虑最大公约数的原理，对于任意两个数$x$,$y$，以及一个公因数$p$(质数),那么这个质数对于gcd有贡献的部分肯定是这两个数所拥有的最小幂次。所以可以预处理出每一个数的最小的质因数的幂次，然后不断除，用欧拉降幂计算答案贡献即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int mod=998244353,maxn=1000000;int cs[maxn][24],cnt,pri[maxn],ycl[10000005],n,sz[1000015];long long ans;bool vis[1000015];inline void prime()&#123; vis[1]=true; for(register int i=2;i&lt;=maxn;i++)&#123; if(!vis[i]) pri[++cnt]=i,ycl[i]=i; for(register int j=1;i*pri[j]&lt;=maxn&amp;&amp;j&lt;=cnt;j++)&#123; vis[i*pri[j]]=true,ycl[i*pri[j]]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;int qpow(int a, int b)&#123; int res = 1, base = a; while(b &gt; 0)&#123; if(b &amp; 1) res = 1LL*res*base%mod; base=1LL*base*base%mod; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123;// freopen("test.txt","r",stdin); scanf("%d",&amp;n); prime(); ans=1; for(register int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;sz[i]); while(sz[i]&gt;1)&#123; int tmp=ycl[sz[i]],tot=0; while(sz[i]%tmp==0) sz[i]/=tmp,cs[tmp][++tot]++; &#125; &#125; for(register int i=1;i&lt;=cnt;i++)&#123; int sum=0; for(int j=1;j&lt;=18;j++)&#123; int tmp=cs[pri[i]][j]; if(tmp&lt;=1) break; (sum+=1LL*tmp*(tmp-1)/2%(mod-1))%=(mod-1); &#125; (ans*=(1LL*qpow(pri[i],sum)))%=mod; //if(i==1) printf("%d %d %d %d\n",pri[i],sum,ans); &#125; printf("%lld",ans); return 0;&#125; deco的str思路奇妙的hash。首先预处理出S的所有hash值，同时求出T的所有循环连接的hash值，然后求出前缀和，查询即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int mod=1000000007,maxn=10000015,P=100007;char S[10000005],T[10000005];int tot,lens,lent,seed=131;ull ver[maxn],p[maxn],h[maxn],f[maxn],zz,edge[10000005];int Nxt[10000005],head[10000005];long long ans;inline void insert(ull x)&#123; for(register int u=head[x%P];u;u=Nxt[u])&#123; if(ver[u]==x) &#123;edge[u]++;return;&#125; &#125; ver[++tot]=x,edge[tot]=1,Nxt[tot]=head[x%P],head[x%P]=tot;&#125;inline int query(ull x)&#123; int res=0; for(register int u=head[x%P];u;u=Nxt[u]) if(ver[u]==x) return edge[u]; return 0;&#125;inline ull gethash(int L,int R)&#123; return h[R]-h[L-1]*p[R-L+1];&#125;int main()&#123; scanf("%s",S+1);lens=strlen(S+1); scanf("%s",T+1);lent=strlen(T+1); if(lens&lt;lent*2)&#123; printf("0");return 0; &#125; p[0]=1;for(register int i=1;i&lt;=lens;i++)p[i]=p[i-1]*seed; for(register int i=1;i&lt;=lens;i++)h[i]=h[i-1]*seed+S[i]-'a'+1; for(register int i=1;i&lt;=lent;i++) zz=zz*seed+T[i]-'a'+1; insert(zz); for(register int i=1;i&lt;=lent;i++)zz=(zz-(T[i]-'a'+1)*p[lent-1])*seed+T[i]-'a'+1,insert(zz); for(register int i=lent;i&lt;=lens;i++) f[i]=query(h[i]-h[i-lent]*p[lent]); for(register int i=lent*2;i&lt;=lens;i++)&#123; ans=(ans+1LL*f[i]*f[i-lent]%mod)%mod; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客暑期noip提高组模拟(四) 解题报告]]></title>
    <url>%2F2019%2F08%2F22%2Fnowcoder4%2F</url>
    <content type="text"><![CDATA[A 麻将思路因为可以交换无数次，所以可以枚举行数和右端点。 问题就转化为了类似广告牌问题。 开一个前缀和记录$sum_j$表示j为右端点的连续1的个数. 然后开一个桶，记录长度，更新答案即可。 代码123456789101112131415161718192021222324252627282930#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;int ans,n,m,tmp,jz[5005][5005],sum[5005],tong[5005];int main()&#123;// freopen("test.txt","r",stdin); scanf("%d%d",&amp;n,&amp;m); for(register int i=1;i&lt;=n;i++)&#123; for(register int j=1;j&lt;=m;j++)&#123; scanf("%d",&amp;jz[i][j]); &#125; &#125; for(register int i=1;i&lt;=m;i++)&#123; for(register int j=1;j&lt;=n;j++)&#123; if(jz[j][i]==1) sum[j]=sum[j]+1; else sum[j]=0; tong[sum[j]]++; &#125; int tj=0; for(register int j=m;j&gt;=1;j--)&#123; tj+=tong[j],ans=max(ans,j*tj),tong[j]=0; &#125; &#125; printf("%d",ans); return 0;&#125; B 卖羊驼思路很明显是一个四边形不等式优化。 首先考虑$O(n^3)$暴力，设$dp_{k,i}$为分了k组，右端点为$i$时的写出转移方程就是$dp_{k,i}=max{dp_{k-1,j}+sum_{j+1,i}}$,其中$sum_{j+1,i}$表示的是从$j+1$到$i$所有数异或起来的值，直接n方预处理一下就好了。 然后考虑优化，可以根据四边形不等式的其他分组题（？）来得出这道题的优化方式：一定是从${k-1,i}$到${k,i+1}$中找决策点。然后记录决策点即可。 代码1234567891011121314151617181920212223242526272829303132#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int sum[5005][5005],ans,n,zu,p[5005],s[1005][5005];long long dp[1005][5005];int main()&#123;// freopen("test.txt","r",stdin); scanf("%d%d",&amp;n,&amp;zu); for(register int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;p[i]); for(register int j=1;j&lt;=i;j++)&#123; sum[j][i]=sum[j][i-1]|p[i]; &#125; &#125; for(register int i=1;i&lt;=zu;i++) s[i][n+1]=n-1; for(register int k=1;k&lt;=zu;k++)&#123; for(register int i=n;i&gt;=1;i--)&#123; for(register int j=s[k-1][i];j&lt;=s[k][i+1];j++)&#123; if(dp[k][i]&lt;dp[k-1][j]+sum[j+1][i])&#123; dp[k][i]=dp[k-1][j]+sum[j+1][i]; s[k][i]=j; &#125; &#125; &#125; &#125; printf("%lld",dp[zu][n]); //printf("%d",ans); return 0;&#125; C 清新题思路线性基加书上启发式合并的裸题，，，然而本垃圾不会所以敲了个暴力还写挂了（丢人）。 dfs一次，回溯时合并更新答案就好了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;const int maxn=100010;int tot,head[maxn],ver[maxn&lt;&lt;1],ans[maxn],Nxt[maxn&lt;&lt;1],n,m,val[maxn];int xxj[maxn][20];inline void add(int u,int v)&#123; ver[++tot]=v,Nxt[tot]=head[u],head[u]=tot;&#125;inline void insert(int u,int xb)&#123; for(register int i=18;i&gt;=0;i--)&#123; if(u&amp;(1&lt;&lt;i))&#123; if(xxj[xb][i]) u^=xxj[xb][i]; else &#123; xxj[xb][i]=u; return; &#125; &#125; &#125;&#125;inline void merge(int xb1,int xb2)&#123; for(register int i=0;i&lt;=18;i++)&#123; if(!xxj[xb2][i]) continue;int u=xxj[xb2][i]; insert(u,xb1); &#125;&#125;inline void dfs(int u,int fa)&#123; insert(val[u],u); for(register int i=head[u];i;i=Nxt[i])&#123; if(ver[i]==fa) continue; dfs(ver[i],u); merge(u,ver[i]); &#125; for(register int i=18;i&gt;=0;i--) ans[u]=max(ans[u],ans[u]^xxj[u][i]);&#125;int main()&#123;// freopen("test.txt","r",stdin); scanf("%d",&amp;n); for(register int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v);add(u,v);add(v,u); &#125; for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;val[i]); dfs(1,0); scanf("%d",&amp;m); for(register int i=1;i&lt;=m;i++)&#123; int q; scanf("%d",&amp;q); printf("%d\n",ans[q]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>玄学</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客暑期noip提高组模拟(二) 解题报告]]></title>
    <url>%2F2019%2F08%2F20%2Fnowcoder2%2F</url>
    <content type="text"><![CDATA[A ACGT思路没啥好说的,直接上trie树暴力匹配即可。注意由于每个序列只能选一次所以最后ans除以2. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int cnt,n,ans,len[100005],sum[100005*20],trie[100005*20][5];char sr[100005][25];inline int getid(char ch)&#123; if(ch=='A') return 1; else if(ch=='T') return 2; else if(ch=='G') return 3; else if(ch=='C') return 4;&#125;inline int deal(char ch)&#123; if(ch=='A') return 2; else if(ch=='T') return 1; else if(ch=='G') return 4; else if(ch=='C') return 3;&#125;inline void insert(int x)&#123; int now=0; for(register int i=1;i&lt;=len[x];i++)&#123; int tmp=getid(sr[x][i]); if(!trie[now][tmp]) trie[now][tmp]=++cnt; now=trie[now][tmp]; &#125; sum[now]++;&#125;inline void query(int x)&#123; int now=0; for(register int i=1;i&lt;=len[x];i++)&#123; int tmp=deal(sr[x][i]); if(!trie[now][tmp]) return; else now=trie[now][tmp]; &#125; if(sum[now])&#123; sum[now]--; ans++; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;i++)&#123; scanf("%s",sr[i]+1); len[i]=strlen(sr[i]+1); insert(i); &#125; for(register int i=1;i&lt;=n;i++)&#123; query(i); &#125; printf("%d",ans/2); return 0;&#125; B 幸运数字考试思路根据题意找出1~$10^{18}$内所有符合条件的数,预处理一下,然后由于数据范围很毒,开一下ull输入,特判如果大于18位时满足条件的数就输出十个4和7,否则直接lower_bound()查找满足条件的数. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;ull T,sz[10000005],cnt,sr;char ch[55];bool fx;inline void dfs(int pos,ull now,int cnt4,int cnt7)&#123; if(cnt4==cnt7)&#123; sz[++cnt]=now; &#125; if(cnt4&gt;10||cnt7&gt;10||pos==19) return; dfs(pos+1,now*10LL+4,cnt4+1,cnt7); dfs(pos+1,now*10LL+7,cnt4,cnt7+1);&#125;inline void init()&#123; dfs(1,4LL,1,0); dfs(1,7LL,0,1); sort(sz+1,sz+cnt+1);&#125;int main()&#123;// freopen("test.txt","r",stdin); ios::sync_with_stdio(false); cin&gt;&gt;T; init(); for(register int i=1;i&lt;=T;i++)&#123; cin&gt;&gt;sr; ull ls=sr; int jsq; while(ls)&#123; ls=ls/10; jsq++; &#125; if(sr&gt;777777777444444444)&#123; for(register int i=1;i&lt;=10;i++) cout&lt;&lt;4; for(register int i=1;i&lt;=10;i++) cout&lt;&lt;7; cout&lt;&lt;endl; continue; &#125; int xb=lower_bound(sz+1,sz+cnt+1,sr)-sz; cout&lt;&lt;sz[xb]&lt;&lt;endl; &#125; return 0;&#125; C滑块这篇题解咕了，没啥营养价值所以也不打算补（？）。]]></content>
      <categories>
        <category>OI</category>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>trie树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客暑期noip提高组模拟(一) 解题报告]]></title>
    <url>%2F2019%2F08%2F19%2Fnowcoder1%2F</url>
    <content type="text"><![CDATA[A 最短路思路很明显和最短路本身没啥关系。 把所有边的边权排个序，然后任意相邻的两条边如果边权之差大于$s$很明显就不能构造出这样的图，这时输出$-1$即可。否则直接按照顺序用双指针记录重边然后连边，思路不难。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;using namespace std;int tot,n,s,maxv,now;bool flag=false;struct node&#123; int bh; int dis;&#125;sz[50500];inline bool cmp(node cp1,node cp2)&#123; if(cp1.dis==cp2.dis) return cp1.bh&lt;cp2.bh; return cp1.dis&lt;cp2.dis;&#125;int main()&#123;// freopen("a.in","r",stdin);// freopen("test.txt","w",stdout); scanf("%d%d",&amp;n,&amp;s); for(register int i=1;i&lt;=n;i++)&#123; int tmp; scanf("%d",&amp;tmp); sz[i].dis=tmp; sz[i].bh=i; &#125; sort(sz+2,sz+n+1,cmp); for(register int i=2;i&lt;=n;i++)&#123; if(sz[i].dis-sz[i-1].dis&gt;s||sz[i].dis==0)&#123; printf("-1"); return 0; &#125; &#125; int pre=0,zq=0,now=0,bj=1; printf("%d\n",n-1); for(register int i=2;i&lt;=n;i++)&#123; if(sz[i].dis!=now)&#123; printf("%d %d %d\n",bj,sz[i].bh,sz[i].dis-now); pre=bj; zq=now; now=sz[i].dis; bj=sz[i].bh; &#125;else&#123; printf("%d %d %d\n",pre,sz[i].bh,sz[i].dis-zq); &#125; &#125; return 0;&#125; B 最小生成链思路看到异或第一反应是个trie树，然而仔细一看是边权和，又觉得不可行。仔细读题，会发现枚举的事实上是所有排列当中最大异或值最小的那个，复杂度为$O(n!)$。回顾位运算和异或的性质，二进制下任意位有多个$0$且有$1$时此位才有贡献，因此从1枚举到n找出这个位（二进制意义下），然后枚举所有边，复杂度$O(n^2)$ 我们发现，只有找出的那一位为1去与为0计算才会最大有贡献，因此维护一个trie树，将所有找出那一位为0的树插入，并且用为1的树查询异或值更新答案即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;using namespace std;int tot,n,s,maxv,now;bool flag=false;struct node&#123; int bh; int dis;&#125;sz[50500];inline bool cmp(node cp1,node cp2)&#123; if(cp1.dis==cp2.dis) return cp1.bh&lt;cp2.bh; return cp1.dis&lt;cp2.dis;&#125;int main()&#123;// freopen("a.in","r",stdin);// freopen("test.txt","w",stdout); scanf("%d%d",&amp;n,&amp;s); for(register int i=1;i&lt;=n;i++)&#123; int tmp; scanf("%d",&amp;tmp); sz[i].dis=tmp; sz[i].bh=i; &#125; sort(sz+2,sz+n+1,cmp); for(register int i=2;i&lt;=n;i++)&#123; if(sz[i].dis-sz[i-1].dis&gt;s||sz[i].dis==0)&#123; printf("-1"); return 0; &#125; &#125; int pre=0,zq=0,now=0,bj=1; printf("%d\n",n-1); for(register int i=2;i&lt;=n;i++)&#123; if(sz[i].dis!=now)&#123; printf("%d %d %d\n",bj,sz[i].bh,sz[i].dis-now); pre=bj; zq=now; now=sz[i].dis; bj=sz[i].bh; &#125;else&#123; printf("%d %d %d\n",pre,sz[i].bh,sz[i].dis-zq); &#125; &#125; return 0;&#125; C最小字典最短路这篇题解在咕咕咕的路上，如果你看到了此消息请催博主补锅。]]></content>
      <categories>
        <category>OI</category>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>模拟</tag>
        <tag>trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3177Redundant Paths 题解]]></title>
    <url>%2F2019%2F08%2F15%2Fpoj3177%2F</url>
    <content type="text"><![CDATA[题目链接传送门 Description 问题描述 In order to get from one of the F (1 &lt;= F &lt;= 5,000) grazing fields (which are numbered 1..F) to another field, Bessie and the rest of the herd are forced to cross near the Tree of Rotten Apples. The cows are now tired of often being forced to take a particular path and want to build some new paths so that they will always have a choice of at least two separate routes between any pair of fields. They currently have at least one route between each pair of fields and want to have at least two. Of course, they can only travel on Official Paths when they move from one field to another. Given a description of the current set of R (F-1 &lt;= R &lt;= 10,000) paths that each connect exactly two different fields, determine the minimum number of new paths (each of which connects exactly two fields) that must be built so that there are at least two separate routes between any pair of fields. Routes are considered separate if they use none of the same paths, even if they visit the same intermediate field along the way. There might already be more than one paths between the same pair of fields, and you may also build a new path that connects the same fields as some other path. Input 输入Line 1: Two space-separated integers: F and R Lines 2..R+1: Each line contains two space-separated integers which are the fields at the endpoints of some path. Output 输出Line 1: A single integer that is the number of new paths that must be built. 样例输入7 71 22 33 42 54 55 65 7 样例输出2 思路题意简述：求一个无向连通图中还需加入多少条边能构成一个边双连通分量。 不太好想。假设我们把桥留下来，然后对每个双联通分量进行缩点，因为是连通图，所以就能得到一棵树。 然后对这个树进行加边操作，可以发现一个结论：需要互通的点一定构成一个环。 然后画图不严谨证明得到最后答案就是叶子节点个数除以二然后向上取整。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int maxn=5005,maxm=10005;int tu[maxn][maxn],sum,ans,bkt,dfn[maxn],col[maxn],low[maxn],tot,F,R,head[maxn],cnt,ver[maxm&lt;&lt;1],Nxt[maxm&lt;&lt;1];stack&lt;int&gt; s;int deg[maxn];inline void add(int u,int v)&#123; ver[++tot]=v,Nxt[tot]=head[u],head[u]=tot;&#125;inline void tarjan(int u,int fa)&#123; dfn[u]=low[u]=++cnt; s.push(u); for(register int i=head[u];i;i=Nxt[i])&#123; int v=ver[i]; if(v==fa) continue; if(!dfn[v]) tarjan(v,u),low[u]=min(low[u],low[v]); else low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; bkt++; while(s.top()!=u) col[s.top()]=bkt,s.pop(); col[u]=bkt,s.pop(); &#125;&#125;int main()&#123;// freopen("test.txt","r",stdin); scanf("%d%d",&amp;F,&amp;R); for(register int i=1;i&lt;=R;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(tu[u][v]) continue; tu[u][v]=tu[v][u]=1; add(u,v); add(v,u); &#125; tarjan(1,0); for(register int u=1;u&lt;=F;u++)&#123; for(register int i=head[u];i;i=Nxt[i])&#123; int v=ver[i]; if(col[u]!=col[v]) deg[col[u]]+=1,deg[col[v]]+=1; &#125; &#125; for(register int i=1;i&lt;=bkt;i++)&#123; if(deg[i]==2) sum++; &#125; ans=sum/2+sum%2; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Follow.]]></title>
    <url>%2F2019%2F08%2F14%2FFollow%2F</url>
    <content type="text"><![CDATA[没有密码的话不用找博主了，不会有的 Incorrect Password! No content to display! U2FsdGVkX1+yXeIEUQwmLKW38UEOAJopX+0i/i8nxqukCTQXL7EuTp65YhRcbK5d63s+YeK2myTjXx6Y8KdAbdd7iU3hkA65nL07VFeLVOmIrYfXd4zdwenLskZzAOfg7Ytakm28GRDuHpfrrX+HHntNl9MukQGgz7/VXT4JijF7/5EBOiiWKOLMMvpEQJPy+lEQtNz1mEI3cSJ2ump+RQcR80rfwqwYxLwF++zIzk9Ybdlvwqa66EOMXqxM4RY2GXJTOv11vzetp7IMP+H1uwUFgwg9Bf90005xwF+uu63EyyzmMktU0Nvh2pGf9ZSo56f9H70IGrwp9bi/Rg8RDDSlrKuSFBsZZD4N+6oWeS1Qqdjq4vRFkC/DruBMEBfVmEc1LujB3UwZWhY0uzgjE/A13tJIIXOAMLK/isoE6FIge9/EHoc1eu6Qj1Od1Ow6aQfbJPNPDJdSSztbtGAUKByqezeVA40QN2tkyu/fRAdSJ5nb25HUOJiIYdPwqmp1rkl976lT1G/m5C3UgeOg6zEccv/dNFfup+F4BK6RbKEjxH6VTtYg9SaW3s9P02TDHik1SuJeYB2RtW/oovi9ME6KlWrACze9XvIwmjMeBTQu1vDlBcUqKDlXXgarZ3UcCi6WjE2pgus0Z2Kv7GzpR7zntJDwYdp3aUewjhmA34a5SsZNtPlRTQ07fG/v7c3PWFFso5wNNtG+PUgkm/YpOh9YKNzchjg27Gz9nGD6WW1J348HPCCVmS3P6/rcL3qOfxvwFaSi4gPJ/5Pe39frnmqsxjZMdaNb346jAQTJ7XuYxNDa9whQFfN/w0iz/70gr7lCETTmHu+q+YYMfIAk1BJuEY0kTDuoe5N51GuMhdrAvvlX3Kz1xUl/f1DVItc+sdu18on7Hewb1UMaa9yLLxLhbe4VIxAgKI0sDrIiGVIicyeVVtIjc1flt/ok9/r2iGGJWAATt3Lqtcislq4fjOlWvz/wlhgttrfxUwDxVx7pZcJ2oz16eJtpxiPTg2HxhbLulwZ4XSm12noLutA4leixIepo4s+1aCxNECeZ9NKcLht9JPT+01VJLJhGnm9fhck4eqj6aDS2BbKFG/swjvFyvk6Iw5ohX75nuHYWCoOjT0b1HE/tVywokfCxgzmf91s+tTrRsBqCCIum6P6xwg4GOYlhOVDlqAcbrx8GLuZFNVQGcYfBl1Z3jt+Gf5QycVrnhnkfJW/rBJAthv8p+rtVqEagEXn5EtFXRVoaiVk=]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu3046 Pleasant sheep and big big wolf 题解]]></title>
    <url>%2F2019%2F08%2F14%2Fhdu3046%2F</url>
    <content type="text"><![CDATA[题目来源： 传送门 Problem Description 问题描述In ZJNU, there is a well-known prairie. And it attracts pleasant sheep and his companions to have a holiday. Big big wolf and his families know about this, and quietly hid in the big lawn. As ZJNU ACM/ICPC team, we have an obligation to protect pleasant sheep and his companions to free from being disturbed by big big wolf. We decided to build a number of unit fence whose length is 1. Any wolf and sheep can not cross the fence. Of course, one grid can only contain an animal.Now, we ask to place the minimum fences to let pleasant sheep and his Companions to free from being disturbed by big big wolf and his companions. Input输入There are many cases.For every case: N and M（N,M&lt;=200）then N*M matrix:0 is empty, and 1 is pleasant sheep and his companions, 2 is big big wolf and his companions. Output输出For every case: First line output “Case p:”, p is the p-th case;The second line is the answer. 样例输入4 61 0 0 1 0 00 1 1 0 0 02 0 0 0 0 00 2 0 1 1 0 样例输出Case 1:4 思路题目大意：在一个$(n,m)$的矩阵上，1代表羊，2代表狼，0代表平地，我们有长度为1的一个栅栏（不是放在格子上的，是放在格子和格子之间的空隙上的），问使用最少的栅栏，能够使得狼吃不到羊。(N,M&lt;200)； 建模还是很好想：狼吃不到羊-&gt;不连通-&gt;最小割-&gt;最大流。 然后考虑连边：要求栅栏数，那么很明显所有相邻的地皮要连流量为1的边（双向），然后建立源点$S$和汇点$T$，源点朝所有的狼连出流量为$inf$的边，所有的羊朝汇点也连上流量为$inf$的边。 然后跑最大流就可以了，记住每组数据运行前的初始化。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define inf 999999999using namespace std;const int maxn=1000005;int cnt,s,t,n,m,tot,dep[maxn],head[maxn],ver[maxn],edge[maxn],Nxt[maxn];bool vis[maxn];queue&lt;int&gt; q;inline void add(int u,int v,int l)&#123; ver[++tot]=v,edge[tot]=l,Nxt[tot]=head[u],head[u]=tot; ver[++tot]=u,edge[tot]=0,Nxt[tot]=head[v],head[v]=tot;&#125;inline int deal(int u,int flow)&#123; if(u==t) return flow; int res = flow; for(register int i=head[u]; i ;i=Nxt[i])&#123; if(edge[i]&amp;&amp;dep[ver[i]]==dep[u]+1)&#123; int tmp=deal(ver[i],min(edge[i],res)); edge[i]-=tmp,edge[i^1]+=tmp,res-=tmp; &#125; &#125; return flow-res;&#125;inline bool divdep()&#123; memset(dep,-1,sizeof(dep)); while(!q.empty()) q.pop(); q.push(s); dep[s]=0; while(!q.empty())&#123; int u=q.front();q.pop(); if(u==t) return true; for(register int i=head[u];i;i=Nxt[i]) if(edge[i]&amp;&amp;dep[ver[i]]==-1) dep[ver[i]]=dep[u]+1,q.push(ver[i]); &#125; return false;&#125;int main()&#123; tot=1; int xh=0; while(scanf("%d%d",&amp;n,&amp;m)==2)&#123; xh++; int ans=0; s=0,t=n*m+1; memset(head,0,sizeof(head)); cnt=0; for(register int i=1;i&lt;=n;i++)&#123; for(register int j=1;j&lt;=m;j++)&#123; int tmp; scanf("%d",&amp;tmp); cnt++; if(i&lt;n) add(cnt,cnt+m,1),add(cnt+m,cnt,1); if(j&lt;m) add(cnt,cnt+1,1),add(cnt+1,cnt,1); if(tmp==2) add(cnt,s,inf),add(s,cnt,inf); if(tmp==1) add(cnt,t,inf),add(t,cnt,inf); &#125; &#125; while(divdep())&#123; ans+=deal(s,INT_MAX); &#125; printf("Case %d:\n%d\n",xh,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流学习笔记（一）]]></title>
    <url>%2F2019%2F08%2F13%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网络流学习笔记（一）（未完待续） 简介网络流(network-flows)是一种类比水流的解决问题方法，与线性规划密切相关。在oi中网络流是非常重要的考点。 网络网络是指一个有向图$G=(V,E)$.其中的每一条边$(u,v)\in E$都有一个权值$c(u,v)$,称之为容量，当$(u,v)\notin G$ 时,$c(u,v)=0$. 流f(u,v)=\left\{\begin{split} &f(u,v)&,(u,v)\in E\\ &-f(v,u)&,(v,u)\in E\\ &0&,(u,v)\notin E,(v,u)\notin E \end{split}\right.最大流问题给定一个有向图$G=(V,E)$，把图中的边看作管道，每条边上有一个权值，表示该管道的流量上限。给定源点$s$和汇点$t$，现在假设在$s$处有一个水源，$t$处有一个蓄水池，问从$s$到$t$的最大水流量是多少 Ford-Fulkerson算法基本思路很简单,每次用dfs从源到汇找一条可行路径，然后把这条路塞满。这条路径上容量最小的那条边的容量，就是这次dfs所找到的流量。然后对于路径上的每条边，其容量要减去刚才找到的流量。并对反向边加上相同的流量 。 Edmonds-Karp算法Dicnic算法]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搬迁公告]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%90%AC%E8%BF%81%E5%85%AC%E5%91%8A%2F</url>
    <content type="text"><![CDATA[由于不可抗因素，全站已搬迁，以前的内容只有明文数据储存，会慢慢补上的 在此祝嘉兴职业技术学院的彭洁伟大佐亲妈暴毙。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
</search>
